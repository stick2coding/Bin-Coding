(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{423:function(a,t,s){"use strict";s.r(t);var r=s(2),e=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"面向对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向对象"}},[a._v("#")]),a._v(" 面向对象")]),a._v(" "),t("h2",{attrs:{id:"面向对象是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向对象是什么"}},[a._v("#")]),a._v(" 面向对象是什么？")]),a._v(" "),t("p",[a._v("面向对象是软件开发方法，是编程开发的一种范式。\n贯穿于软件分析、设计和开发各个阶段，对应面向对象就分别称为面向对象分析（OOA）、面向对象设计（OOD）和面向对象编程（OOP）。")]),a._v(" "),t("h3",{attrs:{id:"对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象"}},[a._v("#")]),a._v(" 对象")]),a._v(" "),t("p",[a._v("对象是由数据和允许的操作组成的包，它与目标实体有直接的对应关系。“数据” 包括对象的静态信息，如特性、状态等；“方法” 也就是行为，包括对象的能动信息，如对象的操作、功能等。")]),a._v(" "),t("h3",{attrs:{id:"类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类"}},[a._v("#")]),a._v(" 类")]),a._v(" "),t("p",[a._v("把具有相同行为的对象归纳为类，类是一个抽象的概念，对象是类的具体。")]),a._v(" "),t("h3",{attrs:{id:"面向对象-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向对象-2"}},[a._v("#")]),a._v(" 面向对象")]),a._v(" "),t("p",[a._v("面向对象是基于对象的概念，以对象为中心，以类和继承为构建机制，认识、理解和描绘客观世界，设计和构建相应的软件系统。")]),a._v(" "),t("h3",{attrs:{id:"面向对象和面向过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向对象和面向过程"}},[a._v("#")]),a._v(" 面向对象和面向过程")]),a._v(" "),t("h4",{attrs:{id:"区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[a._v("#")]),a._v(" 区别")]),a._v(" "),t("ol",[t("li",[a._v("面向过程是“执行者思维”，通过把解决问题的过程拆成一个一个的方法，通过按顺序执行方法来解决问题。")]),a._v(" "),t("li",[a._v("面向对象是“设计者思维”，在解决问题前先抽象出对象，再按照解决问题过程中按照对象来组合解决问题。")])]),a._v(" "),t("h4",{attrs:{id:"关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关系"}},[a._v("#")]),a._v(" 关系")]),a._v(" "),t("ul",[t("li",[a._v("都是解决问题的思维方式")]),a._v(" "),t("li",[a._v("面向对象离不开面向过程，面向对象基于对象来设计，但是在对象方法设计以及对象方法调用组合上依然还是面向过程。")])]),a._v(" "),t("h2",{attrs:{id:"面向对象三大特征"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向对象三大特征"}},[a._v("#")]),a._v(" 面向对象三大特征")]),a._v(" "),t("h3",{attrs:{id:"封装"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#封装"}},[a._v("#")]),a._v(" 封装")]),a._v(" "),t("p",[a._v("封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但可以通过提供公开的方法来操作这些内部属性。")]),a._v(" "),t("h3",{attrs:{id:"继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[a._v("#")]),a._v(" 继承")]),a._v(" "),t("p",[a._v("继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能。\n通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。")]),a._v(" "),t("p",[t("strong",[a._v("注意")])]),a._v(" "),t("ol",[t("li",[a._v("子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。")]),a._v(" "),t("li",[a._v("子类可以拥有自己属性和方法，即子类可以对父类进行扩展。")]),a._v(" "),t("li",[a._v("子类可以用自己的方式实现父类的方法。")]),a._v(" "),t("li",[a._v("继承破坏了封装，因为父类对子类开放，修改父类就会导致所有子类改变")])]),a._v(" "),t("h3",{attrs:{id:"多态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多态"}},[a._v("#")]),a._v(" 多态")]),a._v(" "),t("p",[a._v("多态的概念：通俗来说，就是多种形态，具体点就是去完成某个行为，当不同的对象去完成时会产生出不同的状态。")]),a._v(" "),t("h4",{attrs:{id:"多态的前提"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多态的前提"}},[a._v("#")]),a._v(" 多态的前提")]),a._v(" "),t("p",[a._v("两个对象存在继承关系；\n表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。")]),a._v(" "),t("h4",{attrs:{id:"多态的具体体现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多态的具体体现"}},[a._v("#")]),a._v(" 多态的具体体现")]),a._v(" "),t("ul",[t("li",[a._v("编译类型和运行类型可以不一致；")]),a._v(" "),t("li",[a._v("定义一个对象，编译类型看等号左边，运行类型看等号右边；")]),a._v(" "),t("li",[a._v("如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。")])]),a._v(" "),t("h2",{attrs:{id:"创建一个对象有几种方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建一个对象有几种方式"}},[a._v("#")]),a._v(" 创建一个对象有几种方式")]),a._v(" "),t("p",[a._v("5种")]),a._v(" "),t("h3",{attrs:{id:"new关键字"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#new关键字"}},[a._v("#")]),a._v(" new关键字")]),a._v(" "),t("p",[a._v("可以调用任意的构造器（无参的和有参的）。")]),a._v(" "),t("h3",{attrs:{id:"class-newinstance"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#class-newinstance"}},[a._v("#")]),a._v(" Class.newInstance")]),a._v(" "),t("ul",[t("li",[a._v("运用反射创建对象时最常用的方法。")]),a._v(" "),t("li",[a._v("Class类的newInstance使用的是类的public的无参构造器。前提是必须有public的无参构造器才行，否则报错。")])]),a._v(" "),t("h3",{attrs:{id:"constructor-newinstance"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#constructor-newinstance"}},[a._v("#")]),a._v(" Constructor.newInstance")]),a._v(" "),t("h3",{attrs:{id:"clone"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#clone"}},[a._v("#")]),a._v(" clone")]),a._v(" "),t("ul",[t("li",[a._v("用clone方法创建对象并不会调用任何构造函数")]),a._v(" "),t("li",[a._v("要使用clone方法，我们必须先实现Cloneable接口并复写Object的clone方法。")]),a._v(" "),t("li",[a._v("如果被clone对象里有其他对象比如A，clone克隆后的对象的指针都是指向内存中的同一个A，这种复制称为浅复制，如果需要clone完成深复制则需要在A也实现Cloneable接口和重写clone方法。")])]),a._v(" "),t("h3",{attrs:{id:"反序列化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#反序列化"}},[a._v("#")]),a._v(" 反序列化")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('public class Main {\n\n    public static void main(String[] args) throws Exception {\n        Person person = new Person("test", 18);\n        byte[] bytes = SerializationUtils.serialize(person);\n\n        // 字节数组：可以来自网络、可以来自文件（本处直接本地模拟）\n        Object deserPerson = SerializationUtils.deserialize(bytes);\n        System.out.println(person);\n        System.out.println(deserPerson);\n        System.out.println(person == deserPerson);\n    }\n}\n')])])]),t("p",[a._v("输出")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Person")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("name"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token char"}},[a._v("'test'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" age"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("18")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Person")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("name"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token char"}},[a._v("'test'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" age"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("18")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("false")]),a._v("\n")])])]),t("h2",{attrs:{id:"深拷贝和浅拷贝区别了解吗-什么是引用拷贝"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝和浅拷贝区别了解吗-什么是引用拷贝"}},[a._v("#")]),a._v(" 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？")]),a._v(" "),t("ul",[t("li",[a._v("浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。")]),a._v(" "),t("li",[a._v("深拷贝 ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。")]),a._v(" "),t("li",[a._v("引用拷贝：两个不同的引用指向同一个对象。")])]),a._v(" "),t("h2",{attrs:{id:"接口、抽象类、抽象方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口、抽象类、抽象方法"}},[a._v("#")]),a._v(" 接口、抽象类、抽象方法")]),a._v(" "),t("h3",{attrs:{id:"抽象方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#抽象方法"}},[a._v("#")]),a._v(" 抽象方法")]),a._v(" "),t("p",[a._v("Java中使用abstract关键字修饰的方法为抽象方法，抽象方法没有方法体。")]),a._v(" "),t("p",[a._v("抽象方法没有方法体，但是没有方法体的不一定都是抽象方法，比如Java中还有一类native方法（本地方法）没有方法体。")]),a._v(" "),t("h3",{attrs:{id:"抽象类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#抽象类"}},[a._v("#")]),a._v(" 抽象类")]),a._v(" "),t("p",[a._v("抽象类也是使用abstract关键字来声明的，它可以包含0到多个抽象方法，抽象类无法直接实例化对象，需要通过多态的方式实现，子类继承抽象类必须实现抽象类的所有抽象方法。\n抽象类和普通类相比，就是多了抽象方法。")]),a._v(" "),t("p",[t("strong",[a._v("注意")])]),a._v(" "),t("ol",[t("li",[a._v("抽象类本身无法实例化")]),a._v(" "),t("li",[a._v("抽象类可以没有抽象方法，但是一个类中定义了抽象方法，那么这个类一定是抽象类")]),a._v(" "),t("li",[a._v("abstract 和 final 和 private 不能同时出现。否则无法进行实例化")]),a._v(" "),t("li",[a._v("抽象类在继承抽象类时可以不重写抽象方法。但是普通类继承时就需要重写所有抽象方法")]),a._v(" "),t("li",[a._v("抽象类和抽象方法存在的意义就是强制子类覆写某些方法")])]),a._v(" "),t("h3",{attrs:{id:"接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[a._v("#")]),a._v(" 接口")]),a._v(" "),t("p",[a._v("Java中使用interface来定义接口，接口中只有全局常量和抽象方法。\n接口与接口之间可以使用extends关键字实现继承，接口的继承是多继承的（并不是所有的继承都是单继承的）。")]),a._v(" "),t("h2",{attrs:{id:"构造方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造方法"}},[a._v("#")]),a._v(" 构造方法")]),a._v(" "),t("p",[a._v("主要作用是为了完成对象的初始化")]),a._v(" "),t("h3",{attrs:{id:"没有构造方法是否可以"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#没有构造方法是否可以"}},[a._v("#")]),a._v(" 没有构造方法是否可以")]),a._v(" "),t("p",[a._v("可以。会有默认的无参构造方法。")]),a._v(" "),t("p",[t("strong",[a._v("注意")])]),a._v(" "),t("ol",[t("li",[a._v("当我们添加了自己的构造方法时，就不会自动添加默认的无参构造方法")]),a._v(" "),t("li",[a._v("当我们重载了有参的构造方法时，都要把无参的构造方法写出来。")]),a._v(" "),t("li",[a._v("构造方法的名字和类名相同，没有返回值，不能用 void 声明")]),a._v(" "),t("li",[a._v("构造方法不能重写，但可以重载，一个类可以有多个构造方法")])]),a._v(" "),t("h2",{attrs:{id:"对象的比较"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象的比较"}},[a._v("#")]),a._v(" 对象的比较")])])}),[],!1,null,null,null);t.default=e.exports}}]);